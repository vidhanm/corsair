import { eventBus } from '../core/event-bus.js'
import { CorsairEvent } from '../types/events.js'
import type {
  QueryDetectedEvent,
  NewQueryAddedEvent,
  NewMutationAddedEvent,
  LLMAnalysisStartedEvent,
} from '../types/events.js'
import { generateStub } from '../generators/stub-generator.js'
import { generateQueryWithLLM } from '../generators/llm-generator.js'
import { fileWriteHandler } from './file-write-handler.js'
import type { Query, SchemaDefinition } from '../types/state.js'
import { stateMachine } from '../core/state-machine.js'
import { llm } from '../../../llm/index.js'
import { z } from 'zod'
import { operationGeneratorPrompt } from '../../../llm/prompts/operation-generator.js'
import { mutationGeneratorPrompt } from '../../../llm/prompts/mutation-generator.js'
import { getProvider } from '../core/provider.js'

/**
 * Query Generator Handler
 *
 * Listens to: QUERY_DETECTED, NEW_QUERY_ADDED, NEW_MUTATION_ADDED
 * Emits: GENERATION_STARTED, GENERATION_PROGRESS, GENERATION_COMPLETE, GENERATION_FAILED
 */
class QueryGenerator {
  private schema: SchemaDefinition = { tables: [] }

  // Define the schema for LLM response
  public llmResponseSchema = z.object({
    input_type: z
      .string()
      .describe(
        'The input type of the function. This will be added to the input_type of the operation. This input type is what your function will receive as input.'
      ),
    function: z
      .string()
      .describe(
        'The actual logic of the function. This will be added to the handler of the operation. The response type will be inferred from the function.'
      ),
    optimistic: z
      .string()
      .optional()
      .describe(
        'For mutations only: optimistic update function that returns preview state before server confirms.'
      ),
    validate: z
      .string()
      .optional()
      .describe(
        'For mutations only: validation function that checks permissions and business rules before execution.'
      ),
    notes: z
      .string()
      .describe(
        'Any additional notes or instructions for the function that you will receive later as configuration rules.'
      ),
    pseudocode: z
      .string()
      .describe(
        'High-level pseudocode describing what the function does, its inputs, outputs, and main steps.'
      ),
    function_name: z
      .string()
      .describe(
        'A concise, unique, kebab-case or camelCase function name suggestion suitable for naming a file.'
      ),
  })

  constructor() {
    this.setupListeners()
  }

  private setupListeners() {
    eventBus.on(
      CorsairEvent.QUERY_DETECTED,
      this.handleQueryDetected.bind(this)
    )

    eventBus.on(
      CorsairEvent.NEW_QUERY_ADDED,
      this.handleNewQueryAdded.bind(this)
    );

    eventBus.on(
      CorsairEvent.NEW_MUTATION_ADDED,
      this.handleNewMutationAdded.bind(this)
    );

    eventBus.on(
      CorsairEvent.LLM_ANALYSIS_STARTED,
      this.handleLLMAnalysisStarted.bind(this)
    )
  }

  private async handleQueryDetected(data: QueryDetectedEvent) {
    const writer = fileWriteHandler
    const query: Query = {
      id: data.id,
      nlQuery: data.nlQuery,
      sourceFile: data.sourceFile,
      params: data.params,
      lineNumber: data.lineNumber,
      timestamp: Date.now(),
    }

    try {
      // Emit generation started
      eventBus.emit(CorsairEvent.GENERATION_STARTED, { queryId: query.id })

      // Step 1: Generate and write stub immediately
      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: 'Creating stub',
        percentage: 10,
      })

      const stubContent = generateStub(query)
      const outputPath = writer.getQueryOutputPath(query.id)

      writer.writeFile(outputPath, stubContent, { createDirectories: true })

      // Step 2: Generate actual query with LLM (stub for now)
      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: 'Generating query logic',
        percentage: 40,
        message: 'Analyzing schema...',
      })

      await new Promise(resolve => setTimeout(resolve, 300))

      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: 'Generating query logic',
        percentage: 60,
        message: 'Creating Drizzle query...',
      })

      const generatedQuery = await generateQueryWithLLM(query, this.schema)

      // Step 3: Write final query
      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: 'Writing files',
        percentage: 80,
      })

      const finalContent = `// Auto-generated by Corsair
// Query: "${query.nlQuery}"
// Source: ${query.sourceFile}:${query.lineNumber}

${generatedQuery.types}

${generatedQuery.queryCode}

export default ${generatedQuery.functionName};
`

      writer.writeFile(outputPath, finalContent, { overwrite: true })

      // Step 4: Complete
      eventBus.emit(CorsairEvent.GENERATION_PROGRESS, {
        queryId: query.id,
        stage: 'Complete',
        percentage: 100,
      })

      eventBus.emit(CorsairEvent.GENERATION_COMPLETE, {
        queryId: query.id,
        outputPath,
        generatedFiles: [outputPath],
      })
    } catch (error) {
      eventBus.emit(CorsairEvent.GENERATION_FAILED, {
        queryId: query.id,
        error: error instanceof Error ? error.message : 'Unknown error',
        code: 'GENERATION_ERROR',
      })
    }
  }

  public updateSchema(schema: SchemaDefinition) {
    this.schema = schema
  }

  private async handleNewQueryAdded(data: NewQueryAddedEvent) {
    // Only process LLM for initial detection (no configurationRules)
    // User-submitted operations will be handled through LLM_ANALYSIS_STARTED event
    if (data.configurationRules === undefined) {
      await this.processWithLLM({
        operationType: "query",
        operationName: data.operationName,
        functionName: data.functionName,
        prompt: data.prompt,
        file: data.file,
        lineNumber: data.lineNumber,
        configurationRules: data.configurationRules,
      });
    }
  }

  private async handleNewMutationAdded(data: NewMutationAddedEvent) {
    // Only process LLM for initial detection (no configurationRules)
    // User-submitted operations will be handled through LLM_ANALYSIS_STARTED event
    if (data.configurationRules === undefined) {
      await this.processWithLLM({
        operationType: "mutation",
        operationName: data.operationName,
        functionName: data.functionName,
        prompt: data.prompt,
        file: data.file,
        lineNumber: data.lineNumber,
        configurationRules: data.configurationRules,
      });
    }
  }

  private async processWithLLM(operation: {
    operationType: 'query' | 'mutation'
    operationName: string
    functionName: string
    prompt: string
    file: string
    lineNumber: number
    configurationRules?: string
  }) {
    const schema = stateMachine.getSchema()
    if (!schema) {
      throw new Error('Schema not found')
    }
    try {
      // Create a detailed prompt for the LLM
      const message = operation.operationType === 'mutation'
        ? mutationGeneratorPrompt({
            schema,
            name: operation.operationName,
          })
        : operationGeneratorPrompt({
            schema,
            type: operation.operationType,
            name: operation.operationName,
          })

      // Get the configured provider
      const provider = getProvider()

      // Call the LLM
      const response = await llm({
        provider,
        prompt: `You are an expert TypeScript developer specializing in Corsair framework operations and Drizzle ORM. Your task is to generate high-quality, type-safe database operation handlers.

## Core Responsibilities
Generate the \`input_type\` Zod schema and \`handler\` function for Corsair queries and mutations that:
- Use Drizzle ORM patterns correctly
- Handle database relationships and joins properly
- Follow TypeScript and Corsair best practices
- Include proper error handling and validation
- Are performant and secure

## Corsair Operation Structure
Each operation has this structure:
\`\`\`typescript
const operation = createQuery<DatabaseContext>()({
  prompt: "natural language description",
  input_type: z.object({ /* Zod schema */ }),
  dependencies: { tables: [...], columns: [...] },
  handler: async (input, ctx) => {
    // Your generated code here
    return result;
  }
});
\`\`\`

## Drizzle ORM Patterns

### Basic Operations
\`\`\`typescript
// Select all
const items = await ctx.db.select().from(ctx.schema.tableName);

// Select with where
const item = await ctx.db
  .select()
  .from(ctx.schema.tableName)
  .where(drizzle.eq(ctx.schema.tableName.id, input.id))
  .limit(1);

// Insert
const [newItem] = await ctx.db
  .insert(ctx.schema.tableName)
  .values(input)
  .returning();

// Update
const [updatedItem] = await ctx.db
  .update(ctx.schema.tableName)
  .set(input)
  .where(drizzle.eq(ctx.schema.tableName.id, input.id))
  .returning();
\`\`\`

### Joins and Relationships
\`\`\`typescript
// Inner join
const results = await ctx.db
  .select({
    // Select specific fields
    itemId: ctx.schema.items.id,
    itemName: ctx.schema.items.name,
    relatedData: ctx.schema.related.data
  })
  .from(ctx.schema.items)
  .innerJoin(
    ctx.schema.related,
    drizzle.eq(ctx.schema.items.id, ctx.schema.related.item_id)
  )
  .where(drizzle.eq(ctx.schema.items.id, input.id));

// Complex joins with grouping
const albumWithArtists = await ctx.db
  .select({
    albumId: ctx.schema.albums.id,
    albumName: ctx.schema.albums.name,
    artist: {
      id: ctx.schema.artists.id,
      name: ctx.schema.artists.name,
    }
  })
  .from(ctx.schema.albums)
  .innerJoin(ctx.schema.album_artists, drizzle.eq(ctx.schema.albums.id, ctx.schema.album_artists.album_id))
  .innerJoin(ctx.schema.artists, drizzle.eq(ctx.schema.album_artists.artist_id, ctx.schema.artists.id))
  .where(drizzle.eq(ctx.schema.albums.id, input.id));
\`\`\`

### Search and Filtering
\`\`\`typescript
// Text search
const results = await ctx.db
  .select()
  .from(ctx.schema.tableName)
  .where(drizzle.ilike(ctx.schema.tableName.name, \`%\${input.query}%\`));

// Multiple conditions
const results = await ctx.db
  .select()
  .from(ctx.schema.tableName)
  .where(
    drizzle.and(
      drizzle.eq(ctx.schema.tableName.status, 'active'),
      drizzle.gte(ctx.schema.tableName.created_at, input.since)
    )
  );
\`\`\`

## Input Type Guidelines
- Use descriptive property names
- Include proper validation (min, max, optional, etc.)
- For IDs: \`z.string()\` or \`z.string().uuid()\`
- For search: \`z.string().min(1)\`
- For numbers: \`z.number().min(0)\` etc.
- For optional fields: \`z.string().optional()\`

## Error Handling Patterns
\`\`\`typescript
// Handle missing records
const [item] = await ctx.db.select()...;
if (!item) {
  return null; // or throw error depending on use case
}

// Handle array results
if (results.length === 0) {
  return []; // return empty array for lists
}
\`\`\`

## Performance Tips
- Use \`.limit(1)\` for single record queries
- Select only needed columns in joins
- Use appropriate indexes in where clauses
- Avoid N+1 queries by using joins

## Response Format
Return exactly this JSON structure:
{
  "input_type": "z.object({ id: z.string(), ... })",
  "function": "async (input, ctx) => { /* complete handler code */ }",
  "notes": "Additional implementation details or considerations",
  "pseudocode": "Step-by-step pseudocode of the handler: inputs, process, outputs",
  "function_name": "conciseUniqueFunctionName or concise-unique-function-name"
}

The \`input_type\` should be a valid Zod schema string.
The \`function\` should be a complete async handler implementation.
The \`notes\` should explain any complex logic or important considerations.
Provide clear \`pseudocode\` covering parameters, validation, database interactions, and the returned shape.
Ensure \`function_name\` is unique, descriptive, and suitable for a filename.`,
        schema: this.llmResponseSchema,
        message,
      })

      if (response) {
        // Process successful LLM response
        eventBus.emit(CorsairEvent.LLM_ANALYSIS_COMPLETE, {
          operationName: operation.operationName,
          operationType: operation.operationType,
          response,
          operation,
        })
      } else {
        // Handle LLM failure
        eventBus.emit(CorsairEvent.LLM_ANALYSIS_FAILED, {
          operationName: operation.operationName,
          operationType: operation.operationType,
          error: 'LLM analysis failed - no response received',
        })
      }
    } catch (error) {
      console.error('LLM processing error:', error)

      eventBus.emit(CorsairEvent.LLM_ANALYSIS_FAILED, {
        operationName: operation.operationName,
        operationType: operation.operationType,
        error: error instanceof Error ? error.message : 'Unknown error',
      })
    }
  }

  private async handleLLMAnalysisStarted(data: LLMAnalysisStartedEvent) {
    // This handler should only process user-initiated LLM analysis from the state machine
    // Auto-detected operations are handled directly by handleNewQueryAdded/handleNewMutationAdded

    // Get the current operation from state machine when LLM analysis is requested
    const currentState = stateMachine.getCurrentState()
    const newOperation = currentState.context.newOperation

    if (!newOperation) {
      console.warn('LLM analysis started but no operation found in state')
      return
    }

    // Only process if this is a user-submitted operation (has configurationRules or from state machine)
    if (
      newOperation.configurationRules !== undefined ||
      currentState.state === 'LLM_PROCESSING'
    ) {
      await this.processWithLLM({
        operationType: newOperation.operationType,
        operationName: newOperation.operationName,
        functionName: newOperation.functionName,
        prompt: newOperation.prompt,
        file: newOperation.file,
        lineNumber: newOperation.lineNumber,
        configurationRules: newOperation.configurationRules,
      })
    }
  }
}

// Initialize handler
export const queryGenerator = new QueryGenerator()
